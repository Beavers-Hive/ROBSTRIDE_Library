#include <M5Unified.h>
#include <math.h>

#ifdef USE_TWAI
#include "RS02PrivateTWAI.h"
#else
#include <SPI.h>
#include <mcp_can.h>
#include "RS02PrivateCAN.h"
#endif

// ===== IDs =====
constexpr uint8_t HOST_ID = 0x00;
constexpr uint8_t MOTOR_ID = 0x7E;

#ifdef USE_TWAI
// M5AtomS3 など: ビルドフラグ未指定なら既定のTX/RXを使用
#ifndef TWAI_TX_GPIO
#define TWAI_TX_GPIO 2
#endif
#ifndef TWAI_RX_GPIO
#define TWAI_RX_GPIO 1
#endif
RS02PrivateTWAI RS(HOST_ID, TWAI_TX_GPIO, TWAI_RX_GPIO);
#else
// MCP2515 利用時の設定（基板に合わせて修正）
#define CAN_CS_PIN 6
#define CAN_BAUD CAN_1000KBPS
#define MCP_CLOCK MCP_8MHZ // 16MHz基板なら MCP_16MHZ
MCP_CAN CAN(CAN_CS_PIN);
RS02PrivateCAN RS(CAN, HOST_ID);
#endif

// ===== 動作パラメータ =====
static const float LIMIT_SPD_RAD_S = 6.0f; // 位置ループの最大速度
static const float LIMIT_CUR_A = 5.0f;     // 電流上限（保護）
static const float KP_LOC = 5.0f;          // 位置Kp（必要に応じて調整）
static const float TARGET_MAG_RAD = 12.0f; // 目標位置の絶対値

static const uint32_t INITIAL_INTERVAL_MS = 3000; // 初回インターバル（3秒）
static const uint32_t MIN_INTERVAL_MS = 200;      // 下限インターバル
static const float INTERVAL_DECAY = 0.85f;        // インターバル縮小率（15%短縮）

// ===== 状態管理 =====
static bool cspReady = false;
static int8_t targetSign = +1; // +1: +12rad, -1: -12rad
static uint32_t currentIntervalMs = INITIAL_INTERVAL_MS;
static uint32_t nextSwitchAtMs = 0;

static inline void sendCspRef(float posRad)
{
  RS.cspLocRef(MOTOR_ID, posRad);
  Serial.printf("[CSP] ref -> %.2f rad\n", posRad);
}

void setup()
{
  auto cfg = M5.config();
  M5.begin(cfg);
  Serial.begin(115200);
  delay(50);

#ifdef USE_TWAI
  if (!RS.begin())
  {
    Serial.println("[TWAI] begin FAIL");
    while (1)
      delay(1000);
  }
#else
  SPI.begin();
  if (CAN.begin(MCP_ANY, CAN_BAUD, MCP_CLOCK) != CAN_OK)
  {
    Serial.println("[CAN] begin FAIL");
    while (1)
      delay(1000);
  }
  CAN.setMode(MCP_NORMAL);
  RS.begin();
#endif

  RS.setMasterId(0xFD);

  // CSPモードへ強固に遷移し、上限/ゲインを設定
  bool ok = RS.enterCSP_robust(MOTOR_ID, LIMIT_SPD_RAD_S, LIMIT_CUR_A, KP_LOC);
  Serial.printf("[CSP] bringup %s\n", ok ? "OK" : "NG");

  if (ok)
  {
    cspReady = true;
    float pos0 = TARGET_MAG_RAD * (float)targetSign; // +12rad
    sendCspRef(pos0);
    nextSwitchAtMs = millis() + currentIntervalMs; // 3秒後に切替
    Serial.printf("[CSP] interval=%lu ms\n", (unsigned long)currentIntervalMs);
  }
}

void loop()
{
  M5.update();

  if (!cspReady)
  {
    delay(5);
    return;
  }

  // インターバル経過で、未到達でも次の指令に割り込み
  if ((int32_t)(millis() - nextSwitchAtMs) >= 0)
  {
    // 目標符号を反転して送信（+12 <-> -12）
    targetSign = -targetSign;
    float posNext = TARGET_MAG_RAD * (float)targetSign;
    sendCspRef(posNext);

    // インターバルを段階的に短縮
    uint32_t decayed = (uint32_t)((float)currentIntervalMs * INTERVAL_DECAY);
    currentIntervalMs = decayed < MIN_INTERVAL_MS ? MIN_INTERVAL_MS : decayed;
    nextSwitchAtMs = millis() + currentIntervalMs;
    Serial.printf("[CSP] next in %lu ms\n", (unsigned long)currentIntervalMs);
  }

  delay(2);
}
